import{_ as r,c as s,a4 as t,o as a}from"./chunks/framework.qvkBPMhT.js";const k=JSON.parse('{"title":"Redis","description":"","frontmatter":{"outline":"deep","title":"Redis"},"headers":[],"relativePath":"broker/redis.md","filePath":"broker/redis.md","lastUpdated":1691592127000}'),d={name:"broker/redis.md"};function o(i,e,c,l,p,n){return a(),s("div",null,e[0]||(e[0]=[t('<h2 id="redisbroker" tabindex="-1">RedisBroker <a class="header-anchor" href="#redisbroker" aria-label="Permalink to &quot;RedisBroker&quot;">​</a></h2><p><code>RedisBroker</code> 是基于 <code>Redis</code> 的<a href="https://redis.io/docs/data-types/streams/" target="_blank" rel="noreferrer">Stream</a> 实现的 <code>Broker</code>。</p><div class="warning custom-block"><p class="custom-block-title">⚠️版本</p><p>Redis只有5.0版本以上才支持Stream，如果需要使用RedisBroker，请确保Redis版本在5.0以上。</p></div><details class="details custom-block"><summary>为什么不使用Redis 发布订阅 (pub/sub)？</summary><p>Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></details>',4)]))}const u=r(d,[["render",o]]);export{k as __pageData,u as default};
